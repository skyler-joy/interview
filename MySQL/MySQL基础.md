## MySQL基础知识

### 1.什么是MySQL

MySQL是一个开源的关系型数据库管理系统，利用结构化查询语句SQL进行数据库管理

### 2.MySQL常用的存储引擎有什么？他们有什么区别

- InnoDB

  InnoDB是MySQL默认的存储引擎，支持事务、行锁、外键、并发等操作，聚簇索引，

- MyISAM

  MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性很差，不支持事务、行锁、外键等操作，默认的锁的粒度为表级锁，非聚簇索引

- MEMORY：

  所有的数据都在内存中，数据的处理速度快，但是安全性不高

- Archive:

  如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archiv

### 3.数据库的三大范式是什么

- 第一范式：保证每列的原子性，数据表中的所有字段值都是不可分解的原子值
- 第二范式：保证表中每列都与主键相关
- 第三范式：保证每列都与主键直接相关而不是间接相关

### 4.❤MySQL的数据类型有哪些？

- 整数（TINYINT / SMALLINT / MEDIUMINT /INT / BIGINT）


- 浮点数（FLOAT / DOUBLE / DECIMAL【利用字符串，效率更低】）


- 字符串 （CHAR 【定长,未满补空格】 / VARCHAR 【可变，空间效率高，】）：varchar更节省空间。应用场景：对于经常变更的数据使用char更好，char不容易产生碎片。**CHAR**的存取速度要比**VARCHAR**快得多，因为其长度固定，方便程序的存储与查找；但是CHAR为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可以说是以空间换取时间效率，而VARCHAR则是以空间效率为首位的。


- 日期  （year / time /date / datetime【秒，8字节，与时区无关】 / timestamp【秒，四字节，与时区相关】）：尽量使用timestamp,相比于datetime它有着更高的空间效率

## 索引

### 1.什么是索引

索引是对数据库表的一列或者多列的值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息

### 2.索引的优缺点

- 优点：

  1.大大加快了数据检索的速度，

  2.将随机I/O变成顺序I/O(因为B+数的叶子结点是连接在一起的)，

  3.可以加快表与表之间的连接


- 缺点：

  1.创建索引和维护索引需要时间成本，这个成本随着数据量的增大而加大；

  2.创建索引和维护索引需要空间成本，这个数据量越大，占用空间也越大；

  3.会减低表的增删改的效率，因为每次操作都需要进行动态维护，导致时间变长

### 3.❤索引的数据结构?

索引的数据结构主要是B+树和哈希表，对应的索引分别是B+树索引和哈希索引。InnoDB引擎的索引主要是是B+树和哈希索引，默认的索引类型是B+树。

- B+树索引

  1.所有的记录节点都是按照键值大小的顺序放在叶子节点，B+树具有有序性，并且所有的数据都存放在叶子节点，内部节点只有key值，没有value值

  2.B+树的索引又可以分为主索引和辅助索引，其中主索引为聚簇索引，辅助索引为非聚簇索引，聚簇索引的叶子节点存储着完整的数据记录。非聚簇索引是以非主键的列作为B+数的键值所构成的B+数索引，非聚簇索引的叶子节点存储着主键值。使用非聚簇索引进行查询时会进行回标查询

- 哈希索引

  哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列通过哈希算法进行哈希计算得到哈希码，将哈希码作为哈希表额key值，将指向数据行的指针作为哈希表的value值。O(1) ，一般用于精准查找

### 4.Hash索引和B+树的区别

哈希表不支持排序，一般多用于精准的等值查找，存在哈希冲突，性能不稳定，B+树支持范围查询，模糊查询和多列索引最左前缀优先匹配，性能是相对稳定的，每次查询都是从根节点到叶子节点

### 5.索引的类型有哪些？

- FULLLTEXT:全文索引，查找文本内容，主要是用来解决模糊查询效率满低的问题


- 普通索引：基本的索引类型


- 唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一


- 主键索引：数据列不允许重复，不能为NULL，一个表只能有一个


- 组合索引：多个列组成的索引，遵循最左前缀匹配原则

### 6.B数和B+树的区别？

- B树的内部节点和叶子节点都会存储键和值，而B+树的内部节点只有键没有值，叶子节点存放所有的键和值
- B+树的叶子节点是有序连接在一起的，方便顺序检索

### 7.❤数据库为什么使用B+树而不是B树？

- **范围检索：**B树只适用于随机检索，B+树适用于随机检索和顺序检索，因为B+树的叶子节点都是连接在一起的，支持范围检索
- **性能：**B+树性能更稳定，每次查询都是从根节点到叶子节点，而B树因为内部节点包含key值和数据的完整记录，所以每次查找的值可能在内部节点就已经找到
- **空间利用率：**B+树的空间利用率更高，因为B+树的内部节点只存储键（key），这样B+树的一个节点就可以存储更多的索引，从而是树的高度遍地，减少I/O次数，加快检索速度

### 8.什么是聚簇索引和非聚簇索引？

最主要区别是数据和索引是否分开存储

- 聚簇索引是将数据和索引放到一起存储，索引结构的叶子节点保留了**数据行**



- 非聚簇索引是将数据和索引分开存储，索引结构的叶子节点存储的是**指向数据行的地址**


### 9.非聚簇索引一定会进行回表查询？

可以通过**索引覆盖**解决非聚簇索引回表查询的问题。

如果查询的数据在辅助索引上完全能获取到便不需要回表查询。

例如一张个人信息表包含id、name、age等字段，假设聚簇索引是以id为键值建的索引，非聚簇索引是以name为键值构建的索引，select id ,name from user where name = 'zhangsan'

### 10.❤索引的使用场景（设计原则，如何优化）

- 对于**中大型表**建立索引非常有效，对于非常小的表，一帮全部表扫描速度更快些，索引列的基数越大，索引的效果越好
- 对于增删改非常少，而查询需求非常多的表，建立索引就很有必要了
- 多个字段经常被查询的话可以考虑组合索引
- 字段多并且字段值没有重复的时候可以考虑唯一索引
- 尽量使用**短索引**（前缀索引），尽量利用**最左前缀匹配原则**，对于较长的字符串进行索引的时候应该指定一个较短的前缀长度，因为较小的索引涉及的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值

### 11.如何创建/删除索引

- create index index_name on table_name(col_name);
- alter table table_name add index index_name(col_name);
- alter table table_name drop index index_name
- alter table table_name drop primary key
- drop index index_name on table_name;

### 12.使用索引查询是性能一定会提升吗？

不一定，因为创建和维护索引需要时间和空间上的代价，如果不合理的使用索引反而会是查询性能下降

### 13.什么是前缀索引

前缀索引是指对文本或者字符串的前几个字符建立索引，这样的索引长度更短，查询速度更快

使用场景：前缀区分度比较高的情况下

### 14.什么是最左匹配原则？

在建立组合索引时，从建立的索引最左边为起点开始连续匹配，遇到**范围查询**(>,<,between,like)会停止匹配

### 15.索引在什么情况下会失效？

- 条件中有or
- 使用like模糊查询以%开头的
- 在索引列上进行计算，使用函数，隐式转化，where a + 1 >100
- 对于组合索引，不遵循最左匹配原则
- 在索引字段上使用is null / is not null判断时会导致索引失败

## 事务

### 1.什么是数据库的事务？

数据库事务是访问并可能操作各种数据项的一个数据库操作序列，这些要么全部执行，要么全部不执行

### 2.事务的四大特性？

- **原子性**：包含事务的操作要么全部执行成功，要么全部执行失败并回滚
- **一致性**：一致性是指事务在执行前后状态是一致的，保证事务按预期生效，即正确性
- **隔离性**：一个事务所进行的修改在最终提交之前，对其他事务是不可见的
- **持久性**：数据一旦提交，其所作的修改将永久的保存在数据库中

### 3.数据库的并发一致性问题

当多个事务并发执行时，可能出现以下问题

- **脏读**：事务A更新了数据，当时还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取的数据就成为脏数据了	

- **不可重复读**：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致

- **幻读**：事务A在读取数据后，事务B向事务A多次读取的数据中插入了几条数据，事务A再次读取数据是发现多了几条数据，和之前读取的数据不一致

- 丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B后修改，事务B的修改覆盖了事务A的修改

不可重复读和幻读的主要区别：在不可重复读中，发现数据不一致主要是数据被更行了；而在幻读中，发现数据不一致主要是数据增多了或者减少了

### 4.数据库的隔离级别有哪些？

- 未提交读：一个事务在提交前，它的修改对其他事务也是可见的

- 提交读：一个事务提交之后，它的修改才能被其他事务看到

- 可重复读：在同一个事务中多次读取到的数据是一致的

- 串行化：需要加锁实现，会强制事务串行执行

  | 隔离级别 | 脏读   | 不可重复读 | 幻读   |
  | ---- | ---- | ----- | ---- |
  | 未提交读 | 允许   | 允许    | 允许   |
  | 提交读  | 不允许  | 允许    | 允许   |
  | 可重复读 | 不允许  | 不允许   | 允许   |
  | 串行化  | 不允许  | 不允许   | 不允许  |

  **MySQL的默认隔离级别是可重复读**

### 5.隔离级别是如何实现的？

事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现

### 6.❤什么是MVCC?

MVCC（多版本并发控制）是一种控制并发的方法，MVCC的作用就是在**避免加锁**的情况下最大限度解决读写并发冲突的问题，它可以实现提交读和可重复读两个隔离级别

在了解MVCC机制之前需要介绍几个概念：

- ReadView（快照读）：数据库中某一个时刻所有未提交事务的快照。

  - 几个重要参数
  - m_ids:表示生成ReadView时，当前系统正在活跃的读写事务的事务ID列表，数组里最小的id为min_id
  - max_id:表示生成ReadView时，当前已创建的最大事务id

- 隐藏列

  - 在InnoDB存储引擎中，它的聚簇索引记录中都包含两个必要的隐藏列，trx_id(事务id)，roll_pointer(回滚指针)

  ![img](https://pic2.zhimg.com/80/v2-bea8db8a629d394cc9dfcba9e640fe95_1440w.webp)


- undo日志
  - MVCC使用到的快照会存储到Undo日志中，该日志通过回滚指针将一个一个数据行的所有快照连接起来。

![mysql_mvcc](../doc/mysql_mvcc.png)

**对比规则**：

1.如果落在绿色部分(trx_id <  min_id),表示这个版本是已提交的事务生成的，这个数据是可见的

2.如果落在红色部分（trx_id>max_id）,表示这个版本是有将来启动是事务生成的，是肯定不可见的

3.如果落在黄色（min_id <= trx_id <=max_id）,分成两种情况

- 若row的trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见
- 若row的trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见

4.对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息里的（deleted_flag）标记为写上true,来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录若果delete_flag标记位为true,意味着已被删除，则不返回数据

**RC隔离级别的事务在每次查询开始时都会生成一个独立的 ReadView**。

**RR隔离级别的事务在第一次读取数据时生成ReadView，之后的查询都不会再生成，所以一个事务的查询结果每次都是一样的**。

### 7.❤既然用了MVCC，为什么还会出现幻读

> mvcc本身是通过trx_id(事务隐藏列)来实现的版本维护，不能读取到ReadView开启时还没提交的事务的记录。
>
> mysql里面实际上有两种读，
>
> 一种是“**快照读**”，比如我们使用select进行查询，就是快照读。在快照读的情况下不会产生幻读的问题。
>
> 另一种读则是“**当前读**”，例如delete，update，insert等语句，都需要满足**直接忽略事务号读取最新数据的要求**。

在快照读模式下可以解决幻读问题，但在当前读读模式下，仅仅依靠MVCC不能解决幻读问题，因为当前读必须获取最新数据

## 锁机制

### 1.什么是数据库的锁？

当数据库有并发事务的时候，保证数据访问顺序的机制成为锁机制

### 2.数据库的锁与隔离级别的关系？

| 隔离级别 | 实现方式                 |
| ---- | -------------------- |
| 未提交读 | 总是读取最新的数据，无需加锁       |
| 提交读  | 读取数据时加共享锁，读取数据后释放    |
| 可重复读 | 读取数据时加共享锁，事务结束后释放共享锁 |
| 串行化  | 锁定整个范围的键，一直持有锁直到事结束  |

### 3.数据库锁的类型有哪些？

- 按粒度

| MySQL锁类别 | 资源开销 | 加锁速度 | 是否会出现死锁 | 锁的粒度 | 并发度  |
| -------- | ---- | ---- | ------- | ---- | ---- |
| **表级锁**  | 小    | 快    | 不会      | 大    | 低    |
| 行级锁      | 大    | 慢    | 会       | 小    | 高    |
| 页级锁      | 一般   | 一般   | 不会      | 一般   | 一般   |

MyISAM默认采用**表级锁**，InnoDB默认采用**行级锁**。

- 从锁的类别上
  - **共享锁**：又称读锁，一个事务对一个数据对象加了读锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加读锁，不能加写锁
  - **排它锁**：又称写锁，一个事务对一个数据对象加了写锁，可以对这个对象进行读取和更新操作。加锁期间，其他事务不能对该数据对象进行加写锁或者读锁

### 4.MySQL中InnoDB引擎的行锁模式及其实如何实现的？

> 在存在行锁和表锁的时候，一个事务相对某个表加写锁，需要先检查是否有其他事务对这个表加了锁或者对这个表的某一行加了锁，对表的每一行都进行检测一次这是非常低效率的，为了解决这种问题，实现多粒度锁机制，InnoDB还有内部使用的意向锁，两种意向锁都是表锁。

**InnoDB实现了以下两种类型的行锁**

- 共享锁（S）
- 排他锁（X)

另外，为了允许行锁和表锁共存，提高效率，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

**实现方式**

InnoDB的行锁是通过给索引上的**索引项加锁**实现的，如果没有索引，InnoDB将通过隐藏的的聚簇索引来对记录进行加锁。

行锁主要是分三种情况：

- Record lock 记录锁:对索引项加锁，存在于包括`主键索引`在内的`唯一索引`中，锁定单条索引记录。
- Grap lock 间隙锁:间隙锁基于`非唯一索引`，它`锁定一段范围内的索引记录`
- Next-key lock 临键锁:可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决`幻读`的问题。 每个数据行上的`非唯一索引列`上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，`InnoDB` 中`行级锁`是基于索引实现的，临键锁只与`非唯一索引列`有关，在`唯一索引列`（包括`主键列`）上不存在临键锁。

InnoDB行锁的特性：如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际产生的效果和表锁是一样的

MVCC不能解决幻读问题，在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题

### 5.❤什么是数据库的乐观锁和悲观锁，如何实现？

- 乐观锁（**读多写少**场景）：系统假设数据的更新在大多数时候是不会产生的冲突的，所以数据库旨在**更新操作提交的时候对数据检测冲突**，如果存在冲突，则数据更新失败。

- 乐观锁实现方式：一般通过**版本号和CAS**（CompareAndSwap）算法实现

  - 给表加一个版本号或时间戳的字段，读取数据时，将版本号一同读出，数据更新时，将版本号加1。

    当我们提交数据更新时，判断当前的版本号与第一次读取出来的版本号是否相等。如果相等，则予以更新，否则认为数据过期，拒绝更新，让用户重新操作。

    ```sql
    begin;
    -- 查找最新版本号version
    select nums, version from tb_goods_stock where goods_id = {$goods_id};
    -- 根据version更新
    update tb_goods_stock set nums = nums - {$num}, version = version + 1 where goods_id = {$goods_id} and version = {$version} and nums >= {$num};
    ```

  - 函数公式：CAS(V,E,N)V：表示要更新的变量E：表示预期值N：表示新值

    ![img](https://pic3.zhimg.com/80/v2-96914c5c8d84c5abd6226afc33423fa6_1440w.webp)

- 悲观锁（读少写多场景）：鉴定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会加上锁（在所有操作前都加锁）。

  悲观锁实现方式：通过数据库的锁机制实现，对查询语句添加**for update**;


### 6.什么是死锁？如何避免？

死锁是**指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象**。在MySQL中，MyISAM是一次获得锁需要的全部锁，要么全部满足，要么等待，所以不会出现死锁问题。在InnoDB中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。****

**如何避免**

- 以固定的顺序访问表和行
- 大事务更倾向于死锁，如果业务允许，**将大事务拆小**
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率
- **降低隔离级别**。如果业务允许，将隔离级别调低也是较好的选择
- **为表添加合理的索引**，可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大

## SQL语句基础知识

### 1.SQL语句主要分为哪几类？

- 数据定义语言DDL（Definition）:Create\Drop\Alter
- 数据库查询语言DQL (Query):   select
- 数据库操纵语言DML(Manipulation):insert/update/delete
- 数据控制功能DCL(Control):grant/revoke

### 2.SQL约束有哪些？

- 主键约束
- 唯一约束
- 外键约束
- Check约束
- 默认约束

### 3.什么是子查询？

把一个查询的结果在另一个查询中使用

- 标量子查询：

  ```sql
  select * from user where age = (select max(age) from user)
  ```

- 列子查询：

  ```sql
  select num1 from table1 where num1 > any (select num2 from table2)
  ```

- 行子查询：

  ```sql
  select * from where (age,sex) = (select age ,sex from user where name = 'zhangsan')
  ```

- 表子查询：

  ```sql
  select * from student where (name ,age ,sex ) in (select name,age,sex from class1)
  ```

### 4.❤了解MySQL的几种连接查询，内连接和外连接的区别？

- 外连接：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL，left / right join
- 内连接：取出两张表中匹配到的数据，匹配不到的不保留
- 交叉连接：使用笛卡尔积的一种连接

### 5.MySQL中in 和exists 的区别是？

in和exists一般用于子查询

- 使用exists时会先进行**外表查询**，将查询到的每一行数据都带入内表查询中看是否满足条件；使用in一般会先进行**内表查询**获取结果集，然后对外表查询匹配结果集，返回数据。
- in在内表查询或者外表查询过程中都会用到索引
- exsits仅在内表查询时会用到索引
- **一般来说，当子查询的结果集比较大，外表较小时用exist效率更高；当子查询的结果较小，外表较大时，使用in效率更高。**
- 对于not in 和 not exists,not exists效率比not in 效率高，与子查询的结果集无关，因为not in 对于内外表都进行了 全表扫描，没有使用到索引。not exists的子查询中可以用到表上的索引


### 6.❤varchar 和 char 的区别？

- varchar 表示**变长**，char 表示**长度固定**，未满填充空格，超出国定长度则拒绝插入并提示错误信息
- **存储容量不同**。对char来说，最多能存放的字符个数为255.对于varchar,最多能存放的字符个数是65532
- **存储速度不同**。char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。varchar空间利用率会更高些。

### 7.MySQL中int(10)、char(10)和varchar(10)的区别是？

int(10)表示显示数据的长度，而char(10)和varchar(10)表示的是存储数据的大小

### 8.drop、delete和truncate的区别

- drop删除整个表，数据行、索引都会被删除，不可回滚
- delete表结构还在，删除表的一部分或全部数据，可回滚
- truncate表结构还在，删除表的全部数据，不可回滚

### 9.union 和 union all 的区别？

union和union all的作用都是将两个结果集合并到一起。

- union会对结果**去重并排序**，union all 直接返回合并后的结果，不去重也不进行排序
- union all 的性能比union性能好

### 10.什么是临时表，什么时候会使用到临时表，什么时候删除临时表？

MySQL在执行SQL的时候会临时创建一些**存储中间结果集**的表，这种表被称为临时表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间

临时表主要分为内存临时表（MEMORY存储引擎）和磁盘临时表（MyISAM存储引擎）。

一般在以下几种情况中会使用到临时表

- From 中的**子查询**
- **distinct**查询并加上order by
- order by 和group by 的子句不一样时
- 使用**union**查询是会产生临时表

### 11.大表数据查询如何进行优化？

- **索引优化**：通过添加索引后，查询的效率得到极大的提升，常用查询的查询时间从原来的几十秒下降到几秒。
- **SQL语句优化**，比如select *，在很多情况下要考虑索引的作用.
- **水平拆分**：水平拆分是指数据表行的拆分，如果表中的数据呈现出某一类特性,比如呈现时间特性,那么可以根据时间段将表拆分成多个。比如对id取模
- **垂直拆分**：垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。表的记录并不多，但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能。这时需要把大的字段拆分到另一个表，并且该表与原表是一对一的关系。
- **使用中间表**：以空间换时间
- **使用缓存技术**：以空间换时间
- 固定长度的表访问起来更快
- 越小的列访问越快

### 12.了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化

慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。

慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

如何优化：

- 分析语句的执行计划，查看SQL语句的**索引**是否命中

- 优化数据库的结构，将字段很多的表分解成多个表（**垂直拆分**），或者考虑建立**中间表**。

- **优化LIMIT分页**：对 limit 分页问题的性能优化方法，可以利用表的 **覆盖索引** 来加速分页查询，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快

  ```sql
  //number为普通索引
  select * from tb_a where number=1 limit 100000, 100;

  --使用子查询优化：

  将上面的语句改为

  select * from tb_a where number = 1 and id >= (select id from tb_a where number = 1 limit 100000, 1) limit 100;
  -- 使用 join 查询优化：

  select * from tb_a as a inner join (select id from tb_a where number = 1 limit 100000, 100) as b on a.id = b.id where a.number = 1;

  --使用 between ... and 优化：

  select * from tb_a where number = 1 and id between 100000 and 100100 limit 100;

  -- 使用 in 优化：

  select * from tb_a where number = 1 and id in (select id from tb_a where number = 1 limit 100000, 100) limit 100; 

  -- 上面4种优化方式都是和 id 主键相关的，也就是说，这需要 id 是连续递增的

  ```

### 13.为什么要设置主键？

主键是唯一区分表中每一行的唯一标识，如果没有主键，更新或者删除表中特定行会很困难，因为不嫩准确地标识某一行

### 14.主键一般用自增ID还是UUID？

一般情况MySQL推荐使用**自增ID**。因为在MySQL中的InnoDB存储引擎中，主键索引是一种聚簇索引，主键索引的B+树的叶子节点按照顺序存储了主键值及数据，如果主键索引是自增ID，只需要按顺序往后排列即可，如果是UUID，ID是随机生成的，在**数据插入时会造成大量数据的移动，产生大量的内存碎片，造成插入性能的下降**。

使用自增ID的好处：

- 字段长度较uuid会**小**很多
- 数据库自动编号，按顺序存放，**利于检索**
- 无需担心主键重复问题

使用自增ID的缺点：

- 因为是自增，在某些业务场景天，容易被其他人查到业务量
- 发生数据迁移时，或者表合并时会非常麻烦
- 在**高并发**的场景下，竞争自增锁会减低数据库的吞吐能力

UUID：通用唯一标识码，基于当前时间、计数器和硬件标识等数据计算生成的

使用UUID的优点：

- 唯一标识，不会考虑重复问题，在数据拆分、合并时也能达到全局的唯一性
- 可以在应用层生成，提高数据库的吞吐能力
- 无需当心业务量泄露的问题

使用UUID的缺点：

- 因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低
- UUID占用空间较大，建立的索引越多，造成的影响越大
- UUID之间比较大小较 自增ID慢不少，影响查询速度

### 15.字段为什么要设置成not null?

NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为not null后仍然可以插入空值

- NULL会影响**一些函数的统计**，比如count,遇到NULL值，这条记录不会统计在内
- B树不存储NULL，索引用不到NULL，会造成第一点中说的统计不到的问题
- Not In子查询在有NULL值的情况下返回的记过都是空值
- MySQL在进行比较的时候，**NULL会参与字段的比较**，因为NUll是一种比较特殊的数据类型，数据库在处理时需要进行特殊处理，增加了数据库处理记录的**复杂性**

### 16.如何优化查询过程中的数据访问？

从减少数据访问方面考虑：

- 正确使用**索引**，尽量做到索引覆盖
- 优化SQL执行计划

从返回更少的数据方面考虑：

- **数据分页处理**
- **只返回需要的字段**

从减少服务器CPU开销方面考虑：

- 合理使用排序
- 减少比较的操作
- **复杂运算在客户端处理**

从增加资源方面考虑：

- 客户端多进程并行访问
- 数据库并行处理

### 17.如何优化长难的查询语句？

- 将一个大的查询**分解**为多个小的查询
- 分解关联查询，使缓存的效率更高

### 18.如何优化LIMIT分页？

- 索引覆盖

  可以利用表的 覆盖索引 来加速分页查询，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。因为利用索引查找有优化算法，且数据块就在查询索引上面，不用再去找相关的数据块，这样节省了很多时间，也就是说，查询的数据就在索引上，不用再经过 回表 的操作。例如：

  ```go
  select id from tb_a where number=1 limit 100000, 100;
  ```

  id 是主键索引（聚簇索引），number 是二级索引（非聚簇索引），二级索引的叶子结点上存储的是主键索引值，而我们只需要查询主键即可，因此就不用 回表 查询多一次。
  ​

- 建立组合索引

### 19.如何优化UNION查询

如果不需要对结果集进行去重或者排序，建议使用UNION ALL ,会好一些

### 20.如何优化Where子句？

- 不要在where子句中使用!=和<>进行不等于判断，这样会导致放弃索引进行全表扫描
- 不要在where子句中使用null或者空值判断，尽量设置字段为Not NULL
- 尽量使用union all 代替 or
- 尽量少使用以“%”开头的模糊查询
- 在where 和 order by 涉及的列建立索引
- 尽量少使用in 或者 not in ,会进行全表扫描（待定）
- 避免在where子句中对字段进行表达式或者函数操作，会导致存储引擎放弃索引进而全表扫描

### 21.SQL语句执行很慢的原因是什么？

- 如果SQL语句只是偶尔执行很慢，可能是执行的时候遇到了锁，也可能是redo log日志写满了，要将redo log 中的数据同步到磁盘中去
  - undo log（**回滚日志**）：是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要用于事务回滚和MVCC。
  - redo log（**重做日志**）：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要用于掉电等故障恢复；
  - binlog （归档日志）：是 Server 层生成的日志，主要用于**数据备份和主从复制**；
- 如果SQL语句一直很慢，可能是字段上没有索引或者字段有索引但是没用上索引

### 22.SQL语句的执行顺序？

```sql
select distinct 
	select_list
from
	left_table
left join
	right_table on join_condition
where
	where_condition
group by 
	group_by_list
having 
	having_condition
order by 
	order_by_condition
limit 
	nums,nums2
	

from -> on -> join -> where -> group -> having ->select -> distinct -> order by 
```

- from :首先对关键字两边的表以笛卡尔积的形式执行连接，并产生一个虚表。续表就是视图，数据会来自多张表的执行结果
- on:  对from连接的结果进行on过滤，并创建续虚拟表V2
- join:对on过滤后的左表添加进来，并创建新的虚拟表V3
- where: 对虚拟表V3进行where刷选，创建虚拟表V4
- group by :对V4中的记录进行分组操作，创建虚拟表V5
- having:对V5进行过滤，创建虚拟表V6
- select:将V6表中的结果按照select进行刷选，创建虚拟表V7
- distinct:对V7表中的结果进行去重操作，创建虚拟表V8,如果使用了group by 子句则无需使用distinct，因为分组的时候是将列中唯一的值分成一组，并且每组值返回一行记录，所以所有的记录都是不同的
- order by:对虚拟表V8中的结果进行排序

## 数据库优化

### 1.❤大表如何优化？

- 限定数据的范围：避免不带任何限制数据范围条件的查询语句。
- **读写分离**：主库负责写，从库负责读
- **垂直分表**：将一个表按照字段分成多个表，每个表存储其中一部分字段
- **水平分表**：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中
- **对单表进行优化**：对表中的字段、索引、查询SQL进行优化
- **添加缓存**
- **中间表**

### 2.什么是垂直分表、垂直分库、水平分表、水平分库？

- **垂直分表**：将一个表按照字段分成多个表，每一个表存储其中一部分字段。一般会将常用的字段放在一个表中，将不常用的字段放到另一张表中。

  优势：

  - 避免IO竞争减少锁表的概率。因为大的字段效率更低，第一个数据量大，需要读取的时间长；第二，大字段占用的空间更大，单页内存储的函数表少了，会使IO操作增多
  - 可以更好的提升热门数据的查询效率


- **垂直分库**：按照**业务**对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上面。

  优势：

  - 降低业务中的耦合，方便对不同的业务进行分级管理
  - 可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题

  垂直拆分的缺点

  - **主键出现冗余**，需要管理冗余列
  - 事务的处理变的复杂
  - 仍然存在单数据量过大的问题


- 水平分表：在同一个数据库中，把同一个表的数据按照一定的规则拆分到多个表中。

  优势：

  - 解决了单表数据量过大的问题
  - 避免IO竞争并减少锁表的概率


- 水平分库：把同一个表的数据按照一定的规则拆分到不同的数据库中，不同的数据库可以放到不同的服务器上面。

  优势：

  - 解决了单库大数据量的瓶颈问题
  - IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳定系和可用性

  水平拆分的缺点：

  - 分片事务一致性难以解决
  - 跨节点JOIN性能查，逻辑会变得复杂
  - 数据扩展难度大，不易维护

在系统设计时根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑缓存，读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较复杂，常见的方案有客户端架构和代理架构

### 3.❤分库分表后，ID键如何处理？

分库分表后不能每个表的ID都是从1开始，所以需要一个**全局ID**，设置全局ID主要有以下几种方法：

- **UUID**：优点：本地生成ID，不需要远程调用；全局唯一不重复。缺点：占用空间大，不适合做为索引
- **数据库自增ID**：在分库分表后使用数据库自增ID，需要一个专门用于生成主键的库，每次服务接收到请求，先向这个库中插入一条没有意义的数据，获取一个数据库自增的ID，利用这个ID去分库分表中写数据。优点：简单易实现。缺点：在高并发下存在瓶颈

![img](https://image.mianshi.online/img202204222219378.PNG)

- **Redis生成ID**：有点：不依赖数据库，性能比较好。缺点：引入新的组件会使得系统复杂度增加
- Twitter的**snowflake算法**：是一个64位的long型的ID，其中有1bit作为毫秒数，41bit作为时间戳，10bit作为工作机器ID，12bit作为序列号。，因为二进制中的第一个bit为1的话为负数，当时ID不能为负数
- 美团的Leaf分布式ID生成系统：[Leaf——美团点评分布式ID生成系统 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2017/04/21/mt-leaf.html)

### 4.❤MySQL的复制原理及流程？如何实现主从复制？

MySQL复制：为保证主服务器和从服务器的数据一致性，在向主服务器插入数据后，从服务器会自动将主服务器中修改的数据同步过来。

主从复制的原理：

主从复制主要有三个线程：binlog线程，I/O线程，SQL线程

- **binlog线程**：负责将主服务器上的数据更改写入到日志binary log中。
- **I/O线程**：负责从主服务器上读取二进制日志（binary log），并写入从服务器的中继日志（relay log）中
- **SQL线程**：负责读取中继日志，解析出主服务器中已经执行的数据更改并在从服务器中重放

![img](https://image.mianshi.online/img202204222226776.jpg)

1.Master在每个事务更新数据完成之前，将操作记录写入到binary log中。

2.Slave从库连接Master主库，并且Master有多少个Slave就会创建多少个binglog dump线程。当Master节点的binlog发生变化时，binlog dump会通知所有的Slave,并将相应的binglog发送给Slave

3.I/O线程接收到binlog内容后，将其写入到中级日志（relay log）中。

4.SQL线程读取中级日志，并在从服务器中重放

![img](https://image.mianshi.online/img202204222228724.PNG)

主从复制的作用：

- **高可用和故障转移**
- **负载均衡**
- **数据备份**
- 升级测试

### 5.了解读写分离吗？

读写分离主要是依赖于主从复制，主从复制为读写分离服务。

读写分离的优势：

- 主服务器负责写，从服务器负责读，缓解了锁的竞争
- 从服务器可以使用MyISAM，提升查询性能及节约系统开销
- 增加冗余，提高可用性